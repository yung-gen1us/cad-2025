# REST. Маршализация JSON

## REST

REST (от англ. REpresentational State Transfer — «передача репрезентативного состояния» или «передача „самоописываемого“ состояния») — архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Другими словами, REST — это набор правил того, как программисту организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать. REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы. В определённых случаях (интернет-магазины, поисковые системы; прочие системы, основанные на данных) это приводит к повышению производительности и упрощению архитектуры. В широком смысле компоненты в REST взаимодействуют наподобие взаимодействия клиентов и серверов во Всемирной паутине. REST является альтернативой RPC.

Гипермедиа-система — это система, в которой информация представлена в виде взаимосвязанных мультимедийных элементов, таких как текст, изображения, аудио, видео и ссылки. Пользователь может переходить между элементами по ссылкам, как это происходит в интернете.

Хотя данная концепция лежит в самой основе Всемирной паутины, термин «REST» был введён Роем Филдингом, одним из создателей протокола «HTTP», лишь в 2000 году. В своей диссертации «Архитектурные стили и дизайн сетевых программных архитектур»  в Калифорнийском университете в Ирвайне он подвёл теоретическую основу под способ взаимодействия клиентов и серверов во Всемирной паутине, абстрагировав его и назвав «передачей представительного состояния» («Representational State Transfer»). Филдинг описал концепцию построения распределённого приложения, при которой каждый запрос (REST-запрос) клиента к серверу содержит в себе исчерпывающую информацию о желаемом ответе сервера (желаемом представительном состоянии), и сервер не обязан сохранять информацию о состоянии клиента («клиентской сессии»).

### Требования к архитектуре REST (Принципы REST)

Существует пять обязательных ограничений для построения распределённых REST-приложений по Филдингу и одно необязательное.

Накладываемые ограничения определяют работу сервера в том, как он может обрабатывать и отвечать на запросы клиентов. Действуя в рамках этих ограничений, система приобретает такие желательные свойства как производительность, масштабируемость, простота, способность к изменениям, переносимость, отслеживаемость и надёжность.

Если сервис-приложение нарушает любое из этих ограничительных условий, данную систему нельзя считать REST-системой.

Обязательными условиями-ограничениями являются:

1. **Клиент-серверная архитектура**
Первым ограничением, применимым к гибридной модели, является приведение архитектуры к модели клиент-сервер. Разграничение потребностей является принципом, лежащим в основе данного накладываемого ограничения. Отделение потребности интерфейса клиента от потребностей сервера, хранящего данные, повышает переносимость кода клиентского интерфейса на другие платформы, а упрощение серверной части улучшает масштабируемость. Наибольшее же влияние на всемирную паутину, пожалуй, имеет само разграничение, которое позволяет отдельным частям развиваться независимо друг от друга, поддерживая потребности в развитии интернета со стороны различных организаций.

---

2. **Отсутствие состояния (stateless)**
Протокол взаимодействия между клиентом и сервером требует соблюдения следующего условия: в период между запросами клиента никакая информация о состоянии клиента на сервере не хранится (Stateless protocol или «протокол без сохранения состояния»). Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. Состояние сессии при этом сохраняется на стороне клиента. Информация о состоянии сессии может быть передана сервером какому-либо другому сервису (например, в службу базы данных) для поддержания устойчивого состояния, например, на период установления аутентификации. Клиент инициирует отправку запросов, когда он готов (возникает необходимость) перейти в новое состояние.

Во время обработки клиентских запросов считается, что клиент находится в переходном состоянии. Каждое отдельное состояние приложения представлено связями, которые могут быть задействованы при следующем обращении клиента.

Каждый запрос клиента к серверу должен содержать всю необходимую информацию — сервер не хранит состояние между запросами.

---

3. **Кеширование**
Как и во Всемирной паутине, клиенты, а также промежуточные узлы, могут выполнять кэширование ответов сервера. Ответы сервера, в свою очередь, должны иметь явное или неявное обозначение как кэшируемые или некэшируемые с целью предотвращения получения клиентами устаревших или неверных данных в ответ на последующие запросы. Правильное использование кэширования способно частично или полностью устранить некоторые проблемы клиент-серверного взаимодействия, ещё больше повышая производительность и масштабируемость системы.

---

4. **Единообразие интерфейса**

+ **Идентификация ресурсов**
Все ресурсы идентифицируются в запросах, например, с использованием URI(Uniform Resource Identifier) в интернет-системах. Ресурсы концептуально отделены от представлений, которые возвращаются клиентам. Например, сервер может отсылать данные из базы данных в виде HTML, XML или JSON, ни один из которых не является типом хранения внутри сервера.

В REST ресурс — это любая сущность, к которой можно обращаться по URL:
Например:

+ Пользователь: /users/42
+ Заказ: /orders/17
+ Статья: /posts/100

+ **Манипуляция ресурсами через представление**
Если клиент хранит представление ресурса, включая метаданные — он обладает достаточной информацией для модификации или удаления ресурса.

Получение пользователя

```http
GET /users/42
```

```json
{
  "id": 42,
  "name": "Иван",
  "email": "ivan@example.com"
}
```

Обновление имени

```http
PUT /users/42
```

```json
{
  "id": 42,
  "name": "Иван Петров",
  "email": "ivan@example.com"
}
```

Это представление не сам ресурс, а его описание/образ, пригодный для работы на клиентской стороне.

+ «Самоописываемые»(self-descriptive messages) сообщения
Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его обрабатывать. К примеру, обработчик сообщения (parser), необходимый для извлечения данных, может быть указан в списке MIME-типов.

  1. Метод запроса
  Например, GET, POST, PUT, DELETE — говорит, что именно делается с ресурсом.
  2. URL (URI)
  Указывает, к какому ресурсу обращаемся.
  3. Заголовки (headers)
  Информация о типе данных, авторизации, формате и т.п.
  Примеры:

  ```http
      Content-Type: application/json
      Authorization: Bearer abc123
  ```

  4. Тело сообщения (body)
  Содержит данные ресурса (если нужно) — например, JSON-объект с пользователем:

  ```json
  {
    "name": "Иван",
    "email": "ivan@example.com"
  }
  ```

Итого:

``` http
PUT /users/42 HTTP/1.1  
Host: api.example.com  
Content-Type: application/json  
Authorization: Bearer abc123  

{
  "name": "Иван Петров",
  "email": "ivan.petrov@example.com"
}
```

+ Гипермедиа как средство изменения состояния приложения (HATEOAS)
Клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервере (к примеру, гиперссылки в гипертексте). Исключая простые точки входа в приложение, клиент не может предположить, что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу. Не существует универсального формата для предоставления ссылок между ресурсами, Web Linking (RFC 5988 -> RFC 8288) и JSON Hypermedia API Language Архивная копия от 27 июня 2014 на Wayback Machine являются двумя популярными форматами предоставления ссылок в REST HYPERMEDIA сервисах.

``` http
GET /users/42
```

``` json 
{
  "id": 42,
  "name": "Иван Иванов",
  "email": "ivan@example.com",
  "_links": {
    "self": { "href": "/users/42" },
    "edit": { "href": "/users/42/edit" },
    "delete": { "href": "/users/42" },
    "friends": { "href": "/users/42/friends" }
  }
}
```

Здесь блок _links — это и есть реализация HATEOAS:
Он говорит клиенту: вот что ты можешь сделать дальше:

+ Посмотреть себя (self)
+ Редактировать (edit)
+ Удалить (delete)
+ Перейти к друзьям (friends)

---

5. **Слои**
Клиент обычно не способен точно определить, взаимодействует ли он напрямую с сервером или же с промежуточным узлом, в связи с иерархической структурой сетей (подразумевая, что такая структура образует слои). Применение промежуточных серверов способно повысить масштабируемость за счёт балансировки нагрузки и распределённого кэширования. Промежуточные узлы также могут подчиняться политике безопасности с целью обеспечения конфиденциальности информации.

---

6. **Код по требованию (необязательное ограничение)**

EST может позволить расширить функциональность клиента за счёт загрузки кода с сервера в виде апплетов или скриптов. Филдинг утверждает, что дополнительное ограничение позволяет проектировать архитектуру, поддерживающую желаемую функциональность в общем случае, но, возможно, за исключением некоторых контекстов.

### Модель зрелости REST-сервисов Леонарда Ричардсона (Richardson Maturity Model)

Леонард Ричардсон — разработчик программного обеспечения и автор, известный своими работами в области веб-архитектуры и проектирования API. Соавтор книг «RESTful Web Services» и «RESTful Web APIs»

Модель делит REST-сервисы на **4 уровня зрелости (от 0 до 3)**.

#### Уровень 0 — «Одноуровневый туннель» (*The Swamp of POX*)

- Один URI для всех операций.
- Используется один HTTP-метод (`POST`).
- Все действия описываются в теле запроса.

**REST не используется.**

**Пример:**
```http
POST /api
Body: { "action": "getUser", "userId": 42 }
```

---

#### Уровень 1 — Использование ресурсов

- У каждого ресурса появляется свой **отдельный URI**.
- HTTP-методы по-прежнему используются неправильно (всё через `POST`).

**⚠ REST используется частично.**

**Пример:**
```http
POST /users/42/delete
```

---

#### Уровень 2 — Правильное использование HTTP-методов

- Используются стандартные HTTP-методы:
  - `GET`, `POST`, `PUT`, `DELETE`
- Ресурсы чётко структурированы по URI.

** Это уже полноценный REST.**

**Примеры:**
```http
GET    /users/42       → получить пользователя  
PUT    /users/42       → обновить пользователя  
DELETE /users/42       → удалить пользователя  
POST   /users          → создать нового пользователя
```

---

#### Уровень 3 — HATEOAS  
(*Hypermedia as the Engine of Application State*)

- Сервер возвращает **гипермедиа-ссылки** с действиями, которые можно выполнить над ресурсом.
- Клиент может динамически перемещаться по API, не зная всех URL заранее.

**🌟 Полная зрелость REST.**

**Пример ответа:**
```json
{
  "id": 42,
  "name": "Иван",
  "_links": {
    "self": { "href": "/users/42" },
    "friends": { "href": "/users/42/friends" },
    "edit": { "href": "/users/42/edit" }
  }
}
```

---

##### Таблица уровней зрелости

| Уровень | Особенности                          | RESTful?       |
|--------:|--------------------------------------|----------------|
| 0       | HTTP как туннель                     | ❌ Нет         |
| 1       | Использование URI для ресурсов       | ⚠ Частично     |
| 2       | HTTP-методы по назначению            | ✅ Да          |
| 3       | HATEOAS (гипермедиа-ссылки)          | 🌟 Полная REST |

## Маршалинг и демаршалинг Java объектов

Маршалинг и демаршалинг — это процессы преобразования объектов в другой формат и обратно.

Маршалинг (marshalling) — это процесс преобразования Java-объекта в другой формат, пригодный для передачи по сети или для сохранения:

+ в JSON
+ в XML
+ в байты
+ в базу данных

Демаршалинг (unmarshalling) — это обратный процесс, преобразование данных (например, из JSON или XML) обратно в Java-объект.

### XML

JAXB(Java Architecture for XML Binding) — стандартной библиотекой Java для маршалинга и демаршалинга объектов в XML и обратно.

С JAXB позволяет:

+ Генерировать XML из Java-объектов
+ Читать XML и автоматически создавать Java-объекты
+ Управлять структурой XML через аннотации

| Аннотация             | Назначение                                                                 |
|-----------------------|----------------------------------------------------------------------------|
| `@XmlRootElement`     | Объявляет корневой элемент XML-документа                                  |
| `@XmlElement`         | Определяет поле как XML-элемент                                           |
| `@XmlAttribute`       | Преобразует поле в XML-атрибут                                            |
| `@XmlType`            | Позволяет задать порядок элементов, имя типа и namespace                  |
| `@XmlTransient`       | Исключает поле из маршалинга/демаршалинга                                |
| `@XmlAccessorType`    | Указывает способ доступа к полям: через поля, свойства или открытые члены |
| `@XmlElementWrapper`  | Оборачивает коллекцию в дополнительный элемент                            |
| `@XmlJavaTypeAdapter` | Позволяет настроить кастомную сериализацию/десериализацию                 |

Подключение

``` kotlin
dependencies {
    implementation("javax.xml.bind:jaxb-api:2.3.1")
    implementation("org.glassfish.jaxb:jaxb-runtime:2.3.1")
    implementation("javax.activation:activation:1.1.1")
}
```

Аннотирование объекта

``` java 
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;

@XmlRootElement(name = "user")
public class User {
    
    private String name;
    private int age;

    // Обязательный публичный конструктор без параметров
    public User() {}

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @XmlElement
    public String getName() {
        return name;
    }

    @XmlElement
    public int getAge() {
        return age;
    }

    // Сеттеры обязательны для демаршалинга
    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```

Маршалинг

``` java

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;

User user = new User("Иван", 30);

// Создание JAXB-контекста
JAXBContext context = JAXBContext.newInstance(User.class);

// Создание маршаллера
Marshaller marshaller = context.createMarshaller();
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true); // форматированный вывод

// Маршалинг: объект → XML (в консоль или файл)
marshaller.marshal(user, System.out);
// marshaller.marshal(user, new File("user.xml"));

```

Результат

``` xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<user>
    <name>Иван</name>
    <age>30</age>
</user>
```

Демаршалинг

``` java
import javax.xml.bind.Unmarshaller;

JAXBContext context = JAXBContext.newInstance(User.class);
Unmarshaller unmarshaller = context.createUnmarshaller();

User user = (User) unmarshaller.unmarshal(new File("user.xml"));
System.out.println(user.getName() + ", " + user.getAge());
```

### JSON

Jackson — это библиотека для:

+ Сериализации Java-объектов в JSON (object → JSON)
+ Десериализации JSON обратно в Java-объекты (JSON → object)

Jackson это мощная, гибкая библиотека,  поддерживает множество форматов (JSON, XML, YAML и др.), но чаще всего используется для JSON 
Примеры работы с Jackson <https://www.baeldung.com/jackson>.

Подключение

```kotlin
dependencies {
    implementation("com.fasterxml.jackson.core:jackson-databind:2.15.0")
}
```

ObjectMapper — это главный “универсальный нож” для работы с JSON.

| Аннотация                          | Назначение                                                                 |
|-----------------------------------|----------------------------------------------------------------------------|
| `@JsonProperty`                   | Связывает JSON-ключ с Java-полем                                          |
| `@JsonIgnore`                     | Игнорирует поле при сериализации/десериализации                           |
| `@JsonInclude`                    | Указывает, включать ли null/пустые значения                               |
| `@JsonCreator`                    | Указывает конструктор или фабричный метод для создания объекта            |
| `@JsonValue`                      | Определяет, какое значение использовать при сериализации объекта          |
| `@JsonFormat`                     | Настраивает формат даты, времени, чисел и т.п.                            |
| `@JsonAlias`                      | Задаёт альтернативные имена для поля при десериализации                   |
| `@JsonAnyGetter` / `@JsonAnySetter` | Обрабатывает произвольные свойства ключ-значение                          |

Класс User с аннотациями

``` java
import com.fasterxml.jackson.annotation.JsonProperty;

public class User {
    @JsonProperty("name")
    private String name;

    @JsonProperty("age")
    private int age;

    public User() {}

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // геттеры и сеттеры
}

```

Сериализация: Java-объект → JSON

```java
import com.fasterxml.jackson.databind.ObjectMapper;

public class Main {
    public static void main(String[] args) throws Exception {
        User user = new User("Иван", 30);

        ObjectMapper mapper = new ObjectMapper();
        String json = mapper.writeValueAsString(user);
        System.out.println(json);
    }
}

```

Десериализация: JSON → Java-объект

``` java

String json = "{\"name\":\"Иван\",\"age\":30}";
User user = mapper.readValue(json, User.class);
System.out.println(user.getName() + ", " + user.getAge());

```
